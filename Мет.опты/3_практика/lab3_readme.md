
# Теория по 3й праке

## Метод половинного деления
Существует довольно очевидная теорема: "Если непрерывная функция на концах некоторого интервала имеет значения разных знаков, то внутри этого интервала у нее есть корень (как минимум, один, но м.б. и несколько)". На базе этой теоремы построено численное нахождение приближенного значения корня функции. Обобщенно этот метод называется **дихотомией**, т.е. **делением отрезка на две части**. 

Обобщенный алгоритм выглядит так:
1. Задать начальный интервал
2. Убедиться, что на концах функция имеет разный знак
3.  Повторять (пока не будет достигнута нужная точность)
	- выбрать внутри интервала точку X
	- сравнить знак функции в точке X со знаком функции в одном из концов
	- если совпадает, то переместить этот конец интервала в точку X
	- иначе переместить в точку X другой конец интервала
	
Варианты метода дихотомии различаются выбором точки деления. Рассмотрим варианты дихотомии:  **метод половинного деления**  и  **метод хорд**.

## Метод половинного деления

**Метод половинного деления**  известен также как  **метод бисекции**. В данном методе интервал делится ровно пополам.

**Плюсы**
- обеспечивает гарантированную сходимость метода, независимо от сложности функции

**Минусы**
- метод никогда не сойдется быстрее, т.е. сходимость метода всегда равна сходимости в наихудшем случае.

### Алгоритм
1.  **Определение начального интервала**: Для начала работы метода необходимо определить интервал  `[a, b]`, на котором функция меняет знак. Это гарантирует наличие корня на этом интервале.
2.  **Вычисление середины интервала**: На каждом шаге алгоритма вычисляется середина текущего интервала  `c = (a + b) / 2`.
3.  **Оценка функции в середине интервала**: Вычисляется значение функции в точке  `c`:  `f(c)`.
4.  **Выбор следующего интервала**: В зависимости от знака  `f(c)`  выбирается новый интервал для следующей итерации:
    -   Если  `f(a) * f(c) < 0`  (знаки функции в точках  `a`  и  `c`  противоположны), то следующий интервал будет  `[a, c]`.
    -   Если  `f(b) * f(c) < 0`  (знаки функции в точках  `b`  и  `c`  противоположны), то следующий интервал будет  `[c, b]`.
5.  **Проверка условия завершения**: Алгоритм повторяется до тех пор, пока длина интервала  `(b - a)`  не станет меньше заданной точности  `\epsilon`. В этом случае точка  `c`  считается приближённым решением.
 
## Метод золотого сечения
Метод золотого сечения — это вычислительный метод поиска экстремума функции одной переменной на заданном отрезке. Использует принцип деления отрезка в пропорциях золотого сечения для поиска экстремума функции. Относительное положение точек деления определяется числами Фибоначчи, что позволяет сохранять одну из точек без изменения на каждой итерации, сокращая количество необходимых вычислений функции.

**Плюсы**

-   Относительно прост в реализации благодаря использованию фиксированных пропорций деления отрезка.
-   Обладает гарантированной сходимостью к оптимальному решению, что делает его надёжным инструментом для поиска экстремумов.
-   Эффективность: Благодаря тому, что на каждой итерации требуется вычислять значение функции только в одной новой точке, метод золотого сечения может быть более эффективным по сравнению с некоторыми другими методами оптимизации.

### Минусы метода

-   при больших значениях (n) метод золотого сечения может иметь большую погрешность, что ограничивает его применимость для задач с очень высокой точностью требований


### Алгоритм
1.  **Начальная установка**: Задаётся отрезок  `[a, b]`, на котором предполагается наличие экстремума функции. Выбираются две точки внутри этого отрезка, которые разделены в пропорциях золотого сечения. Обычно используются числа Фибоначчи для определения этих точек.
2.  **Расчёт значений функции**: В выбранных точках вычисляются значения функции.
3.  **Отбор отрезка**: Из двух концов отрезка  `[a, b]`  выбирается тот, который ближе к точке с большим значением функции (для минимизации). Этот конец отбрасывается, и оставшийся отрезок становится новым рабочим отрезком.
4.  **Повторение процесса**: Шаги 2 и 3 повторяются для нового отрезка. Так как одна из точек остаётся неизменной между итерациями благодаря свойству золотого сечения, на каждой итерации требуется вычислить значение функции только в одной новой точке.
5.  **Условие остановки**: Процесс повторяется до достижения заданной точности, когда разница между границами отрезка становится меньше заданного значения.